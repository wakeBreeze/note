# JVM 探究

- 请你谈谈你对JVM的理解？ Java8虚拟机和之前的变化更新?
- 什么是 OOM ，什么是栈溢出 StackOverFlowError？ 怎么分析？
- JVM的常用调优参数有哪些？
- 内存快照如何抓取，怎么分析Dump文件？
- 谈谈你对 JVM 中，类加载器的认识？



## 1. JVM 的位置

![image-20210125101328151](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210125101328151.png)



## 2. JVM 的体系结构

![image-20210125111546243](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210125111546243.png)

![image-20210125111742686](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210125111742686.png)



## 3. 类加载

一个.java文件在编译后会形成相应的一个或多个Class文件（若一个类中含有内部类，则编译后会产生多个Class文件），但这些Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能被运行和使用。事实上，虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程就是虚拟机的 [**类加载机制**](https://blog.csdn.net/justloveyou_/article/details/72466105)。　　



![preview](https://pic4.zhimg.com/v2-91942e239119811a3f52f55aaaddbc0f_r.jpg)

类加载器作用：加载 Class 文件

![img](https://img-blog.csdnimg.cn/2020121722082798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70)



![image-20210125120003742](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210125120003742.png)

类加载器的级别：

1. BootstrapClassLoader（启动类/根加载器）

   `c++`编写，加载`java`核心库 `java.*`,构造`ExtClassLoader`和`AppClassLoader`。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作

   

2. ExtClassLoader（扩展类加载器）

   `java`编写，加载扩展库，如`classpath`中的`jre` ，`javax.*`或者
   `java.ext.dir` 指定位置中的类，开发者可以直接使用标准扩展类加载器

   

3. AppClassLoader（应用程序/系统类加载器）

   java`编写，加载程序所在的目录，如`user.dir`所在的位置的`class
   
   


4. CustomClassLoader（用户自定义类加载器）

   `java`编写,用户自定义的类加载器,可加载指定路径的`class`文件

   

## 4. 双亲委派机制

从最内层JVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用；

![img](https://img-blog.csdnimg.cn/20201217213314510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70)

注意：应该先看CustomClassLoader有没有加载过，没有则进入ApplicationClassLoader



源码：

```java
public Class<?> loadClass(String name) throws ClassNotFoundException {
    return loadClass(name, false);
}
//              -----??-----
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
        // 首先，检查是否已经被类加载器加载过
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            try {
                // 存在父加载器，递归的交由父加载器
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    // 直到最上面的Bootstrap类加载器
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }
 
            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                //如果BootstrapClassLoader 仍然没有加载过，则递归回来，尝试自己去加载class
                c = findClass(name);
            }
        }
        return c;
}
```


## 5. 沙箱安全机制

沙箱安全：防止恶意代码污染Java源代码

例：比如我定义了一个类名为String所在包为java.lang，因为这个类本来是属于jdk的，如果没有沙箱安全机制的话，这个类将会污染到我所有的String,但是由于沙箱安全机制，所以就委托顶层的bootstrap加载器查找这个类，如果没有的话就委托extsion,extsion没有就到aapclassloader，但是由于String就是jdk的源代码，所以在bootstrap那里就加载到了，先找到先使用，所以就使用bootstrap里面的String,后面的一概不能使用，这就保证了不被恶意代码污染

**[详细](https://blog.csdn.net/qq_30336433/article/details/83268945)**



## 6. Native

native：凡是带了 native 关键字的，说明Java的作用范围打不到了，会去调用底层C语言的库！

- 调用本地方法本地接口	JNI
- JNI作用：扩展Java的使用，融合不同的编程语言为Java所用！  最初：C、C++
- Java单身的时候 C、C++ 横行，想要立足，必须要有调用C、C++的程序
- 它在内存区域中专门开辟了一块标记区域：Native Method Stack，登记 Native 方法
- 在最终执行的时候，通过 JNI 加载本地方法库中的方法
- java程序驱动打印机，管理系统
- 调用其他接口：Socket、WebService、Http~



## 7. PC寄存器

程序计数器：Program Counter Register

​	每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向一条指令的地址，也即将要执行的指令代码），在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计



## 8. 方法区

Method Area 方法区

- 又被称为静态区，它跟堆一样，被所有的线程共享，方法区包含所有的 class 信息 和 static修饰的变量。
- 方法区中包含的都是整个程序中永远唯一的元素，如：class、static变量。

​	

方法区被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，**此区域属于共享区间**；

​	==静态变量、常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是 实例变量存在堆内存中，和方法区无关==



## 9. 栈

栈：数据结构

程序 = 数据结构 + 算法：持续学习~

程序 = 框架 + 业务逻辑：吃饭~

栈：先进后出

队列：先进先出（FIFO)

栈：栈内存，主管程序的运行，生命周期和线程同步；线程结束，栈内存也就释放。==不存在垃圾回收==

栈：8大基本类型 + 对象引用 + 实例的方法

栈运行原理：栈帧

栈满了：StackOverflowError

![image-20210128232555814](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210128232555814.png)





## 10. 三种 JVM

- Sun公司 HotSpot `Java HotSpot(TM) 64-Bit Server VM (build 25.241-b07, mixed mode)`
- BEA `JRockit`
- IBM `J9 VM`



学习基本都是：`HotSpot`



## 11. 堆

Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。

类加载器读取了类文件后，一般会把什么东西放到堆中？	

​	类，方法，常量，变量~，保存我们所有引用类型的真实对象；

堆内存中还要细分为三个区域：

- 新生区	（伊甸园区） Young/New
- 养老区 Old
- 永久区 Perm

![image-20210201102922603](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210201102922603.png)

GC 垃圾回收主要在：伊甸园区和养老区

假设内存满了，OOM，堆内存不够！ java.lang.OutOfMemoryError: Java heap space

在 JDK8以后，永久存储区改了个名字（元空间）



## 12. 新生区、老年区



## 13. 永久区



## 14. 堆内存调优



## 15. GC



    15.1常用算法



## 16. JMM



## 17. 总结



学习途径：

1.百度

2.思维导图