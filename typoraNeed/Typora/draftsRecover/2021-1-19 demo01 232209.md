## JUC并发编程

### 1、并发编程：并发、并行

---

**并发：多线程操作同一个资源**

- cpu单核，模拟出多条线程，划分时间段，快速交替



**并行：多核同时运行**

- cpu多核，多个线程可以同时执行；线程池



**并发编程的本质：**充分利用cpu的资源



**`线程的几个状态`**

```
public enum State {
        //创建
        NEW,

        //运行
        RUNNABLE,

        //阻塞
        BLOCKED,

        //等待-死等
        WAITING,

        //超时等待-等待指定时间
        TIMED_WAITING,

        //终止
        TERMINATED;
    }
```



**`wait/sleep 区别`**

**1、来自不同的类**

- wait => Object

- sleep => Thread

**2、关于锁的释放**

- wait 会释放锁

- sleep 不会释放锁

**3、使用的范围**

- wait-必须在同步代码块中

- sleep-可以在任何地方

**4、wait/sleep 都需要捕获 `InterruptedException` 异常**



### 2、Lock锁（重点）

> **synchronized**

```java
package juc.demo01;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Description: juc.demo01
 * @version: 1.0
 */
public class SaleTicketDemo01 {
    public static void main(String[] args) {
        new Thread(()->{for (int i = 0; i < 30; i++) Ticket.sale(); },"线程A").start();
        new Thread(()->{for (int i = 0; i < 30; i++) Ticket.sale(); },"线程B").start();
        new Thread(()->{for (int i = 0; i < 30; i++) Ticket.sale(); },"线程C").start();
    }
}
//资源类OOP
class Ticket{
    //属性：票数
    private static int ticket_num=30;

    //卖票方法  锁-》对象，class
    public synchronized static void sale(){
        if (ticket_num>0){
            System.out.println(Thread.currentThread().getName()+"卖了第"+(ticket_num--)+"张票，还剩余"+ticket_num+"张票");
        }
    }

```





> **Lock 接口**



![image-20210112163216253](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210112163216253.png)

![image-20210112163520480](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210112163520480.png)

公平锁：先来后到

非公平锁：可以插队（默认）



```java
package juc.demo01;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Description: juc.demo01
 * @version: 1.0
 */
public class SaleTicketDemo02 {
    public static void main(String[] args) {
        new Thread(()->{for (int i = 0; i < 30; i++) Ticket2.sale(); },"线程A").start();
        new Thread(()->{for (int i = 0; i < 30; i++) Ticket2.sale(); },"线程B").start();
        new Thread(()->{for (int i = 0; i < 30; i++) Ticket2.sale(); },"线程C").start();
    }
}
//资源类OOP
class Ticket2{
    //属性：票数
    private static int ticket_num=30;
    //定义锁
    private static Lock lock=new ReentrantLock();

    //卖票方法
    public static void sale(){
        lock.lock();//加锁

        try {
            if (ticket_num>0){
                System.out.println(Thread.currentThread().getName()+"卖了第"+(ticket_num--)+"张票，还剩余"+ticket_num+"张票");
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();//解锁
        }
    }
}

```



> Synchronized 和 Lock 区别

1、Synchronized 内置的Java关键字，Lock 是一个接口

2、Synchronized 无法判断获取锁的状态，Lock 可以判断  是否获取到了锁

3、Synchronized 会自动释放锁，Lock 必须要手动释放锁！如果不释放->**死锁**

4、Synchronized 线程1（获得锁，阻塞）、线程2（一直等待）；Lock 锁就不一定会等待下去；

5、Synchronized 可重入锁，不可以中断，非公平；Lock ，可重入锁，可以判断锁，默认为非公平（可以自己设置，加true变为公平锁）；

6、Synchronized 适合锁少量的代码同步问题，Lock 适合锁大量的同步代码！



> 锁是什么，如何判断锁的是谁！



### 3、生产者和消费者问题

面试的：单例模式、排序算法、生产者和消费者问题、死锁

> 生产者和消费者问题Synchronized 版

if判断加双线程：

```java
package pc;

/**
 * @Description: pc
 * @version: 1.0
 */
public class Demo01 {
    //属性
    private int number=0;

    //三步：判断等待，处理事务，通知
    //+1
    public synchronized void increment() throws InterruptedException {
        /*判断等待，由于wait会立刻释放锁，
        所以可能导致多个线程进入方法，从而引起同步问题
        多个线程在同一个方法中等待，另一个方法调用notifyAll则会触发线程安全问题。
        线程唤醒后会从wait之后继续运行(线程必须重新获得对像锁才能继续执行.因为synchronized代码块内没有锁是寸步不能走的)。
        if只判断一次，所以后面的线程都不需要再次判断，会导致线程安全问题
        while会继续判断，所以当上一个线程修改完值之后，下一个线程判断值时不能通过，所以不会引起线程安全问题
        */
        if (number!=0){
            this.wait();//注意：wait会立即释放锁
        }
        //处理事务
        number++;
        System.out.println(Thread.currentThread().getName()+"->"+number);
        //通知
        this.notifyAll();//会在执行完同步代码块之后释放锁。
    }
    //-1
    public synchronized void decrement() throws InterruptedException {
        //判断等待
        if (number==0){
            this.wait();//注意：wait会立即释放锁
        }
        //处理事务
        number--;
        System.out.println(Thread.currentThread().getName()+"->"+number);
        //通知
        this.notifyAll();//会在执行完同步代码块之后释放锁。
    }

    //这是一个main方法，程序的入口
    public static void main(String[] args) {
        Demo01 demo01 = new Demo01();
        //线程A执行+1操作
        new Thread(()->{
            try {
                for (int i = 0; i < 10; i++) {
                    demo01.increment();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"A").start();

        //线程B执行-1操作
        new Thread(()->{
            try {
                for (int i = 0; i < 10; i++) {
                    demo01.decrement();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"B").start();

    }
}

```

if判断+四线程

```java
package pc;

/**
 * @Description: pc
 * @version: 1.0
 */
public class Demo01 {
    //属性
    private int number=0;

    //三步：判断等待，处理事务，通知
    //+1
    public synchronized void increment() throws InterruptedException {
        //判断等待
        if (number!=0){
            this.wait();//注意：wait会立即释放锁
        }
        //处理事务
        number++;
        System.out.println(Thread.currentThread().getName()+"->"+number);
        //通知
        this.notifyAll();//会在执行完同步代码块之后释放锁。
    }
    //-1
    public synchronized void decrement() throws InterruptedException {
        //判断等待
        if (number==0){
            this.wait();//注意：wait会立即释放锁
        }
        //处理事务
        number--;
        System.out.println(Thread.currentThread().getName()+"->"+number);
        //通知
        this.notifyAll();//会在执行完同步代码块之后释放锁。
    }

    //这是一个main方法，程序的入口
    public static void main(String[] args) {
        Demo01 demo01 = new Demo01();
        //线程A执行+1操作
        new Thread(()->{
            try {
                for (int i = 0; i < 10; i++) {
                    demo01.increment();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"A").start();

        //线程B执行-1操作
        new Thread(()->{
            try {
                for (int i = 0; i < 10; i++) {
                    demo01.decrement();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"B").start();

        //线程C执行+1操作
        new Thread(()->{
            try {
                for (int i = 0; i < 10; i++) {
                    demo01.decrement();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"C").start();

        //线程D执行-1操作
        new Thread(()->{
            try {
                for (int i = 0; i < 10; i++) {
                    demo01.decrement();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"D").start();
    }
}

```

> 问题：A,B,C,D四个线程存在 **虚假唤醒**！

**![image-20210114094836744](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210114094836744.png)**

if 改为 while：

···

```java
package pc;

/**
 * @Description: pc
 * @version: 1.0
 */
public class Demo01 {
    //属性
    private int number=0;

    //三步：判断等待，处理事务，通知
    //+1
    public synchronized void increment() throws InterruptedException {
        /*判断等待，由于wait会立刻释放锁，
        所以可能导致多个线程进入方法，从而引起同步问题
        多个线程在同一个方法中等待，另一个方法调用notifyAll则会触发线程安全问题。
        线程唤醒后会从wait之后继续运行。if只判断一次，所以后面的线程都不需要再次判断，会导致线程安全问题
        while会继续判断，所以当上一个线程修改完值之后，下一个线程判断值时不能通过，所以不会引起线程安全问题
        */
        while (number!=0){
            System.out.println(Thread.currentThread().getName()+"->等待");
            this.wait();//注意：wait会立即释放锁
        }
        //处理事务
        number++;
        System.out.println(Thread.currentThread().getName()+"->"+number);
        //通知
        this.notifyAll();//会在执行完同步代码块之后释放锁。
    }
    //-1
    public synchronized void decrement() throws InterruptedException {
        //判断等待
        while (number==0){
            System.out.println(Thread.currentThread().getName()+"->等待");
            this.wait();//注意：wait会立即释放锁
        }
        //处理事务
        number--;
        System.out.println(Thread.currentThread().getName()+"->"+number);
        //通知
        this.notifyAll();//会在执行完同步代码块之后释放锁。
    }

    //这是一个main方法，程序的入口
    public static void main(String[] args) {
        Demo01 demo01 = new Demo01();
        //线程A执行+1操作
        new Thread(()->{
            try {
                for (int i = 0; i < 10; i++) {
                    demo01.increment();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"A").start();

        //线程B执行-1操作
        new Thread(()->{
            try {
                for (int i = 0; i < 10; i++) {
                    demo01.decrement();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"B").start();

        //线程C执行+1操作
        new Thread(()->{
            try {
                for (int i = 0; i < 10; i++) {
                    demo01.decrement();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"C").start();

        //线程D执行-1操作
        new Thread(()->{
            try {
                for (int i = 0; i < 10; i++) {
                    demo01.decrement();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"D").start();
    }
}
```

但是会引起死锁问题！

参考：https://blog.csdn.net/lixiaoxiong55/article/details/78943766?utm_medium=distribute.pc_relevant.none-task-blog-searchFromBaidu-6.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-searchFromBaidu-6.control



> JUC版的生产者和消费者问题

![image-20210115122047664](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210115122047664.png)

通过Lock 找到 Condition

```java
package pc;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Description: pc
 * @version: 1.0
 */
//用lock锁
public class Demo02 {
    private int num=0;
    //定义锁
    Lock lock=new ReentrantLock();
    Condition condition=lock.newCondition();
    //+1
    public void increment(){
        lock.lock();//加锁
        try {
            //判断等待
            while (num!=0){
                condition.await();
            }
            //处理事务
            num++;
            System.out.println(Thread.currentThread().getName()+"->"+num);
            //通知
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    //-1
    public void decrement(){
        lock.lock();//加锁
        //判断等待
        try {
            while (num==0){
                condition.await();
            }
            //处理事务
            num--;
            System.out.println(Thread.currentThread().getName()+"->"+num);
            //通知
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
        }
    }

    public static void main(String[] args) {
        Demo02 demo02 = new Demo02();
        //线程A
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                demo02.increment();
            }
        },"A").start();
        //线程B
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                demo02.decrement();
            }
        },"B").start();
        //线程C
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                demo02.increment();
            }
        },"C").start();
        //线程D
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                demo02.decrement();
            }
        },"D").start();
    }
}
```

注意：此处也有死锁问题！

**任何一个新的技术，绝对不是仅仅只覆盖了原来的技术，还会有，优势和补充！**

> Condition 精准的通知和唤醒线程

代码测试：

```java
package pc;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Description: pc
 * @version: 1.0
 */
public class Demo03 {
    public static void main(String[] args) {
        Date date = new Date();
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                date.printA();
            }
        },"A").start();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                date.printB();
            }
        },"B").start();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                date.printC();
            }
        },"C").start();
    }
}
class Date{
    private Lock lock=new ReentrantLock();
    private Condition condition1=lock.newCondition();
    private Condition condition2=lock.newCondition();
    private Condition condition3=lock.newCondition();

    private int num=1;

    public void printA(){
        lock.lock();
        try {
            while (num!=1){
                condition1.await();
            }
            num=2;
            System.out.println(Thread.currentThread().getName()+"->AAAA");
            //通知condition2
            condition2.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void printB(){
        lock.lock();
        try {
            while (num!=2){
                condition2.await();
            }
            num=3;
            System.out.println(Thread.currentThread().getName()+"->BBBB");
            //通知condition3
            condition3.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void printC(){
        lock.lock();
        try {
            while (num!=3){
                condition3.await();
            }
            num=1;
            System.out.println(Thread.currentThread().getName()+"->CCCC");
            //通知condition1
            condition1.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}

```



### 4、8锁现象

如何判断锁的是谁！知道什么锁，锁到底锁的是谁！

对象、Class

**深刻理解我们的锁**

```java
package juc.demo01.lock8;

import java.util.concurrent.TimeUnit;

/**
 * @Description: juc.demo01.lock8
 * @version: 1.0
 */
/*8锁：就是关于锁的8个问题
1、标准情况下，两个线程谁先打印，发短信还是打电话？----发短信（main线程内顺序执行，不睡情况下。很大情况发短信会先执行。但是不排除打电话先执行的情况）
2、sendMsg延迟4秒，两个线程谁先打印，发短信还是打电话？----发短信（原因：synchronized锁当前对象-phone，两个线程都是调用同一个对象。）
 */
public class Demo01 {
    public static void main(String[] args) {
        Phone phone=new Phone();
        new Thread(()->{
            phone.sendMsg();
        },"A").start();

        //睡1秒
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            phone.call();
        }).start();
    }
}
class Phone{
    //synchronized锁的对象是方法的调用者！
    //两个方法用的是同一个锁，谁先拿到谁执行。
    //发短信
    public synchronized void sendMsg(){
        //睡2秒
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }
    //打电话
    public synchronized void call(){
        System.out.println("打电话");
    }
}

```

---

```java
package juc.demo01.lock8;

import java.util.concurrent.TimeUnit;

/**
 * @Description: juc.demo01.lock8
 * @version: 1.0
 */
/*
3、增加了一个普通方法，两个线程谁先打印，发短信还是hello？----hello（hello并没有被锁住，发短信延迟了2秒）
4、两个对象，两个同步方法，两个线程谁先打印，发短信还是打电话？----打电话（发短信延迟了2秒）
 */
public class Demo02 {
    public static void main(String[] args) {
        //两个对象，两个调用者，两把锁。
        Phone phone=new Phone();
        Phone2 phone2=new Phone2();
        new Thread(()->{
            phone.sendMsg();
        },"A").start();

        //睡1秒
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            phone2.call();
        }).start();
    }
}
class Phone2{
    //synchronized锁的对象是方法的调用者！
    public synchronized void sendMsg(){
        //睡2秒
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }
    //打电话
    public synchronized void call(){
        System.out.println("打电话");
    }
    //普通方法，没有锁
    public void hello(){
        System.out.println("hello");
    }
}
```

---

```java
package juc.demo01.lock8;

import java.util.concurrent.TimeUnit;

/**
 * @Description: juc.demo01.lock8
 * @version: 1.0
 */
/*
5、增加两个静态的同步方法，只有一个对象，先打印发短信还是打电话？----发短信（锁的是Class对象）
6、两个对象！增加两个静态的同步方法，先打印发短信还是打电话？----发短信（锁的是Class对象）
 */
public class Demo03 {
    public static void main(String[] args) {
        //两个对象的Class类模板只有一个，static，锁的是Class
        Phone3 phone3=new Phone3();
        Phone3 phone3_1=new Phone3();
        new Thread(()->{
            phone3.sendMsg();
        },"A").start();

        //睡1秒
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            phone3_1.call();
        }).start();
    }
}
class Phone3{
    //synchronized锁的对象是方法的调用者！
    //static 静态方法
    //类一加载就有了！加了static之后锁的是Class
    public static synchronized void sendMsg(){
        //睡2秒
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }
    //打电话
    public static synchronized void call(){
        System.out.println("打电话");
    }
    //普通方法，没有锁
    public void hello(){
        System.out.println("hello");
    }
}
```

---

```java
package juc.demo01.lock8;

import java.util.concurrent.TimeUnit;

/**
 * @Description: juc.demo01.lock8
 * @version: 1.0
 */
/*
7、一个静态同步方法，一个同步方法，一个对象，发短信和打电话谁先打印？----打电话（发短信延迟两秒，sendMsg锁的是对象.class;call锁的是对象）
8、一个静态同步方法，一个同步方法，两个对象，发短信和打电话谁先打印？----打电话（发短信延迟两秒，sendMsg锁的是phone4.class；call锁的是phone4_1对象）
 */
public class Demo04 {
    public static void main(String[] args) {
        //两个对象的Class类模板只有一个，static，锁的是Class
        Phone4 phone4=new Phone4();
        Phone4 phone4_1=new Phone4();
        new Thread(()->{
            phone4.sendMsg();
        },"A").start();

        //睡1秒
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            phone4_1.call();
        }).start();
    }
}
class Phone4{
    //synchronized锁的对象是方法的调用者！
    //static 静态方法
    //类一加载就有了！加了static之后锁的是Class
    public static synchronized void sendMsg(){
        //睡2秒
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }
    //打电话
    public synchronized void call(){
        System.out.println("打电话");
    }
}
```

> 小结

new this 具体的一个手机

static Class 唯一的一个模板



### 5、集合类不安全

> List 不安全

```java
package juc.unSafe;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * @Description: juc.unSafe
 * @version: 1.0
 */
//java.util.ConcurrentModificationException 并发修改异常
public class ListTest {
    public static void main(String[] args) {
        //并发下ArrayList 不安全的吗？ synchronized；
        /**
         * 解决方案：
         * 1、List<String> list=new Vector<>();----synchronized(读写都上了synchronized锁）
         * 2、List<String> list= Collections.synchronizedList(new ArrayList<>());
         * 3、List<String> list=new CopyOnWriteArrayList<>();----Lock（写加了Lock锁，读没有加锁）
         */
        /*
        问题：多个线程调用的时候，list，读取的时候（固定）；写入的时候（覆盖）
        CopyOnWrite 写入时复制  COW 计算机程序设计领域的一种优化策略
        在写入的时候避免覆盖，防止造成数据问题！
        读写分离
        CopyOnWriteArrayList 比 Vector 好在哪里？
         */
        List<String> list=new CopyOnWriteArrayList<>();
        for (int i = 0; i < 20; i++) {
            new Thread(()->{
                list.add(UUID.randomUUID().toString().substring(0,5));
                System.out.println(list);
            },String.valueOf(i)).start();
        }
    }
}
```

学习方法：1、先会用；2、对比并寻找各种解决方法；3、分析源码！



> Set 不安全

```java
package juc.unSafe;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * @Description: juc.unSafe
 * @version: 1.0
 */
/*
同理：java.util.ConcurrentModificationException  并发修改异常！
 */
public class SetTest {
    public static void main(String[] args) {
        //Set<String> set=new HashSet<>();//会抛异常：java.util.ConcurrentModificationException
        //Set<String> set= Collections.synchronizedSet(new HashSet<>());  //使用工具类
        Set<String> set= new CopyOnWriteArraySet<>();  //用juc下的类
        for (int i = 0; i < 20; i++) {
            new Thread(()->{
                set.add(UUID.randomUUID().toString().substring(0,5));
                System.out.println(set);
            }).start();
        }
    }
}
```

hashSet 底层是什么？

```java
public HashSet() {
        map = new HashMap<>();
    }
//add set 本质就是 map的key是无法重复的！
public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }

private static final Object PRESENT = new Object();//常量
```



### 6、Callable

---

![image-20210118080836484](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210118080836484.png)

1、类似于Runnalble接口

2、有返回值

3、可以抛出异常

4、实现 call() 方法

> 代码测试

![image-20210118082503899](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210118082503899.png)

![image-20210118082723069](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210118082723069.png)

![image-20210118091308118](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210118091308118.png)

```java
package juc.callable;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/**
 * @Description: juc.callable
 * @version: 1.0
 */
public class CallableTest {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //new Thread(new Runnable()).start();
        //new Thread(new FutureTask<V>()).start();
        //new Thread(new FutureTask<V>(new Callable())).start();

        /*
        new Thread(new FutureTask<>(new MyCallable()),"A").start();//Callable

        new Thread(new FutureTask<>(new Callable<String>() {
            public String call(){
                return "haha";
            }
        })).start();//Callable的匿名内部类

        new Thread(new FutureTask<>(()->{
            return "";
        })).start();//Callable的匿名内部类的lambda表达式
         */

        MyCallable callable = new MyCallable();
        FutureTask futureTask = new FutureTask<>(callable);//适配类
        new Thread(futureTask,"A").start();
        new Thread(futureTask,"B").start();//结果会被缓存，提高效率！ 想要输出两次就再创建一个FutureTask。
        /*
        get方法可能会产生阻塞！
        把他放到最后
        或者使用异步通信来处理！
        */
        String o = (String) futureTask.get();//获取Callable的返回值
        System.out.println(o);

        new Thread(new FutureTask<>(new MyRunnable(),"yes"),"B").start();//Runnable
    }
}
class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        System.out.println("call()");
        //耗时的操作会导致FutureTask.get()产生阻塞
        return "success";
    }
}
class MyRunnable implements Runnable{
    @Override
    public void run() {
        System.out.println("run()");
    }
}
```

**细节：**

1、有缓存

2、结果可能需要等待、会阻塞！



### 7、常用的辅助类（必会）

---

#### 7.1、CountDownLatch （减法计数器）

> 指定个数线程执行完毕后（即当latch数量为0时）再执行countDownLatch.await（）后的操作

![image-20210118095427037](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210118095427037.png)

```java
package juc.add;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * @Description: juc.add
 * @version: 1.0
 */
//减法计数器
public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        //定义总数6，必须要执行任务的时候再使用
        CountDownLatch countDownLatch=new CountDownLatch(6);
        for (int i = 1; i <= 6; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"->go out!");
                //System.out.println(countDownLatch.getCount());
                countDownLatch.countDown();//数量-1
            },String.valueOf(i)).start();
        }
        //countDownLatch.await(2, TimeUnit.SECONDS);//阻塞直到锁存器计数到零或者等待指定时间
        countDownLatch.await();//等到计数器归零，然后向下执行
        System.out.println(countDownLatch.getCount());
        System.out.println("close door!");
    }
}
```

**原理：**

`countDownLatch.countDown();`//数量-1

`countDownLatch.await();`//等待计数器归零，然后向下执行

每次有线程调用 countDown()，数量-1，当计数器变为0时，countDownLatch.await() 就会被唤醒，继续执行！



#### 7.2、CyclicBarrier （加法计数器）

> 当有指定个数线程等待时，开闸，执行每个线程cyclicBarrier.await（）后的操作



![image-20210118105200712](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210118105200712.png)

例1：集齐七颗龙珠召唤神龙

```java
package juc.add;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

/**
 * @Description: juc.add
 * @version: 1.0
 */
//加法计数器
public class CyclicBarrierDemo {
    public static void main(String[] args) {
        /*
        集齐七颗龙珠召唤神龙
         */
        //当给定数量的线程（线程）等待时，它将跳闸，当屏障跳闸时执行给定的屏障动作，由最后一个进入屏障的线程执行。
        CyclicBarrier cyclicBarrier=new CyclicBarrier(7,()->{
            System.out.println("召唤神龙！");
        });
        for (int i = 1; i <= 7; i++) {
            //lambda 表达式内不能操作到i。
            final int num=i;//定义中间变量,1.8之后可以省略final修饰符。jvm中会自动添加。
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"->集齐"+num+"颗龙珠");
                try {
                    cyclicBarrier.await();//等待所有 parties已经在这个障碍上调用了 await 。（让线程阻塞直到有7个线程阻塞于此）
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }

    }
}
```

例2：田径比赛，当所有参赛选手都到入位时（即已有给定数量线程调用cyclicBarrier.await()；），开信号枪，所有选手进入比赛（执行各自线程中的任务）

```java
package juc.add;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

/**
 * @Description: juc.add
 * @version: 1.0
 */
//加法计数器
public class CyclicBarrierDemo {
    public static void main(String[] args) {
        /*
        田径比赛
         */
        //当给定数量的线程（线程）等待时，它将跳闸，当屏障跳闸时执行给定的屏障动作，由最后一个进入屏障的线程执行。
        CyclicBarrier cyclicBarrier=new CyclicBarrier(7,()->{
            System.out.println("所有参赛选手已准备就绪，比赛开始！");
        });
        for (int i = 1; i <= 7; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"号选手准备就绪！");
                try {
                    cyclicBarrier.await();//等待所有 parties已经在这个障碍上调用了 await 。（让线程阻塞直到有7个线程阻塞于此）
                    System.out.println(Thread.currentThread().getName()+"号选手冲入终点！");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            },String.valueOf(i)).start();
        }

    }
}
```



#### 7.3、Semaphore （信号量）

> 同一时间只能有指定数量线程能执行

![image-20210118105643209](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210118105643209.png)

示例：抢车位

```java
package juc.add;

import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

/**
 * @Description: juc.add
 * @version: 1.0
 */
//信号量
public class SemaphoreDemo {
    public static void main(String[] args) {
        //线程数量：停车位；限流！
        Semaphore semaphore=new Semaphore(6);
        for (int i = 1; i <= 12; i++) {
            new Thread(()->{
                try {
                    semaphore.acquire();//获取（从该信号量获取许可证，阻止直到可用）
                    System.out.println(Thread.currentThread().getName()+"进入车位");
                    TimeUnit.SECONDS.sleep(2);//停留二秒
                    System.out.println(Thread.currentThread().getName()+"离开车位");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    semaphore.release();//释放许可证，将其返回到信号量。
                }
            },String.valueOf(i)).start();
        }
    }
}
```

**原理：**

`semaphore.acquire()` 获得许可证（可用许可证-1），假如已经满了（即许可证已经全部给出），那么当前线程将被禁用一进行线程调度，并处于休眠状态！（直至1、release；2、interrupts）

`semaphore.release()` 释放许可证，会将当前的信号量释放+1（可用许可证+1），然后唤醒等待的线程！

**作用：**

- 多个共享资源互斥使用！
- 并发限流，控制最大的线程数！



### 8、读写锁

---

**ReadWriteLock**

![image-20210118154305401](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210118154305401.png)

例：

```java
package juc.readWriteLock;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * @Description: juc.readWriteLock
 * @version: 1.0
 */
/*
独占锁（写锁） 一次只能被一个线程占有
共享锁（读锁） 多个线程可以同时占有
ReadWriteLock
读-读 可以共存！
读-写 不能共存！
写-写 不能共存！
 */
public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCache2 myCache=new MyCache2();
        //写入
        for (int i = 0; i < 5; i++) {
            final int temp=i;
            new Thread(()->{
                myCache.put(temp+"",temp);
            },String.valueOf(i)).start();
        }
        //读取
        for (int i = 0; i < 5; i++) {
            final int temp=i;
            new Thread(()->{
                myCache.get(temp+"");
            },String.valueOf(i)).start();

        }
    }
}
/*
自定义缓存
 */
class MyCache{
    private volatile Map<String,Object> map=new HashMap<>();

    //存/写
    public void put(String key,Object value){
        System.out.println(Thread.currentThread().getName()+"开始写");
        map.put(key, value);
        System.out.println(Thread.currentThread().getName()+"写入完成！");
    }
    //取/读
    public Object get(String key){
        System.out.println(Thread.currentThread().getName()+"读取"+key);
        System.out.println(Thread.currentThread().getName()+"读取完成！");
        return map.get(key);
    }
}
//加锁
class MyCache2{
    private volatile Map<String,Object> map=new HashMap<>();
    //private Lock lock=new ReentrantLock();
    //读写锁，更加细粒度的控制
    private ReadWriteLock readWriteLock=new ReentrantReadWriteLock();
    //存/写
    public void put(String key,Object value){
        //lock.lock();//加锁
        readWriteLock.writeLock().lock();//写锁加锁
        try {
            System.out.println(Thread.currentThread().getName()+"开始写");
            map.put(key, value);
            System.out.println(Thread.currentThread().getName()+"写入完成！");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //lock.unlock();
            readWriteLock.writeLock().unlock();//写锁解锁
        }
    }
    //取/读
    public Object get(String key){
        readWriteLock.readLock().lock();//读锁加锁
        try {
            System.out.println(Thread.currentThread().getName()+"读取"+key);
            System.out.println(Thread.currentThread().getName()+"读取完成！");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.readLock().unlock();//读锁解锁
        }
        return map.get(key);
    }
}
```

### 总结

当分析ReentranctReadWriteLock时，或者说分析内部使用AQS实现的工具类时，需要明白的就是AQS的state代表的是什么。ReentrantLockReadWriteLock中的state同时表示写锁和读锁的个数。为了实现这种功能，state的高16位表示读锁的个数，低16位表示写锁的个数。AQS有两种模式：共享模式和独占模式，读写锁的实现中，读锁使用共享模式；写锁使用独占模式；另外一点需要记住的即使，当有读锁时，写锁就不能获得；而当有写锁时，除了获得写锁的这个线程可以获得读锁外，其他线程不能获得读锁。



### 9、阻塞队列

---

![image-20210118170725250](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210118170725250.png)

队列：

![image-20210118170305722](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210118170305722.png)

写入：如果队列满了，必须阻塞等待读取

读取：如果队列空了，必须阻塞等待写入

![image-20210118164751228](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210118164751228.png)

**BlockingQueue**

什么情况下会使用阻塞队列：多线程并发处理，线程池！

**学会使用队列**

添加、移除

**四组API**

|     方式     | 抛出异常  | 有返回值,不抛出异常 | 阻塞等待 | 超时等待  |
| :----------: | :-------: | :-----------------: | :------: | :-------: |
|     添加     |   add()   |       offer()       |  put()   | offer(,,) |
|     移除     | remove()  |       poll()        |  take()  |  poll(,)  |
| 检测队首元素 | element() |       peek()        |    -     |     -     |

**1、抛出异常**

```java
/*
抛出异常
 */
public static void test(){
    //队列大小-3
    ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);

    System.out.println(blockingQueue.add("a"));
    System.out.println(blockingQueue.add("b"));
    System.out.println(blockingQueue.add("c"));

    //java.lang.IllegalStateException: Queue full 抛出异常！
    //System.out.println(blockingQueue.add("d"));
	
    System.out.println(blockingQueue.element());//检测队首元素
    System.out.println("==================");
    System.out.println(blockingQueue.remove());
    System.out.println(blockingQueue.remove());
    System.out.println(blockingQueue.remove());

    // java.util.NoSuchElementException 抛出异常！
    //System.out.println(blockingQueue.remove());
}
```

**2、有返回值，不会抛出异常**

```java
/*
有返回值，不抛出异常
 */
public static void test2(){
    //队列大小-3
    ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);

    System.out.println(blockingQueue.offer("a"));
    System.out.println(blockingQueue.offer("b"));
    System.out.println(blockingQueue.offer("c"));
    
    System.out.println(blockingQueue.offer("d"));//false  不抛出异常！
    
    System.out.println(blockingQueue.peek());//检测队首元素
    System.out.println("=========================");
    System.out.println(blockingQueue.poll());
    System.out.println(blockingQueue.poll());
    System.out.println(blockingQueue.poll());
    
    System.out.println(blockingQueue.poll());//null  不抛出异常
}
```

**3、阻塞等待**

```java
/*
阻塞等待
 */
public static void test3() throws InterruptedException {
    //队列大小-3
    ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);

    blockingQueue.put("a");
    blockingQueue.put("b");
    blockingQueue.put("c");

    //blockingQueue.put("d");//队列已满，会一直阻塞

    System.out.println(blockingQueue.take());
    System.out.println(blockingQueue.take());
    System.out.println(blockingQueue.take());

    //System.out.println(blockingQueue.take());//队列为空，会一直阻塞
}
```

**4、超时等待**

```java
/*
超时等待
 */
public static void test4() throws InterruptedException {
    //队列大小-3
    ArrayBlockingQueue blockingQueue=new ArrayBlockingQueue<>(3);

    blockingQueue.offer("a");
    blockingQueue.offer("b");
    blockingQueue.offer("c");

    blockingQueue.offer("d",3, TimeUnit.SECONDS);//队列已满，阻塞三秒后继续执行

    System.out.println(blockingQueue.poll());
    System.out.println(blockingQueue.poll());
    System.out.println(blockingQueue.poll());

    System.out.println(blockingQueue.poll(3, TimeUnit.SECONDS));//队列为空，等待三秒后继续执行
}
```



> **SynchronousQueue 同步队列**

**介绍：**SynchronousQueue 也是一个队列来的，但它的特别之处在于它内部没有容器，一个生产线程，当它生产产品（即put的时候），如果当前没有人想要消费产品(即当前没有线程执行take)，此生产线程必须阻塞，等待一个消费线程调用take操作，take操作将会唤醒该生产线程，同时消费线程会获取生产线程的产品（即数据传递），这样的一个过程称为一次配对过程(当然也可以先take后put,原理是一样的)。

- 没有容量
- 进去一个元素，必须等待取出来之后，才能再往里面放入一个元素！
- put、take谁先调用，谁就先阻塞！



```java
package juc.blockingQueue;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;

/**
 * @Description: juc.blockingQueue
 * @version: 1.0
 */
/*
同步队列
 */
public class SynchronizedQueueDemo {
    public static void main(String[] args) {
        SynchronousQueue<String> synchronousQueue = new SynchronousQueue<>();//同步队列
        /*
        谁先进入，谁先阻塞
         */
        new Thread(()->{
            try {
                for (int i = 0; i < 3; i++) {
                    TimeUnit.SECONDS.sleep(1);
                    synchronousQueue.put(String.valueOf(i));//会阻塞直到 synchronousQueue.take()的调用
                    System.out.println(Thread.currentThread().getName()+" put "+i);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"t1").start();

        new Thread(()->{
            try {
                for (int i = 0; i < 3; i++) {
                    //TimeUnit.SECONDS.sleep(1);
                    System.out.println(Thread.currentThread().getName()+"->"+synchronousQueue.take());//会阻塞直到 synchronousQueue.put()的调用

                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"t2").start();
    }
}
```

公平模式下使用：TransferQueue

非公平模式下使用：TransferStack



### 10、线程池（重点）

线程池：三大方法、七大参数、四种拒绝策略

> 池化技术

程序的运行，本质：占用系统的资源！ 优化资源的使用！=> 池化技术

线程池、连接池、内存池、对象池 

池化技术：事先准备好一些资源，有人要用，就来我这里拿，用完之后还给我。



**线程池的好处：**

1、降低资源的消耗（创建、销毁工作十分浪费资源）

2、提高响应的速度

3、方便管理

==**线程复用、可以控制最大并发数、管理线程**==

#### 10.1、三大方法

> **线程池：三大方法**

**`newSingleThreadExecutor`**

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```



**`newFixedThreadPool`**

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```



**`newCachedThreadPool`**

```java
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```





![image-20210119104214095](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210119104214095.png)

```java
package juc.pool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @Description: juc.pool
 * @version: 1.0
 */
/*
Executors:工具类
三大方法：newSingleThreadExecutor、newFixedThreadPool、newCachedThreadPool
核心步骤：
    1、创建线程池
    2、执行任务（用线程池创建线程）
    3、关闭线程池
 */
public class ExecutorsDemo {
    public static void main(String[] args) {
        //创建线程池
        //ExecutorService threadPool = Executors.newSingleThreadExecutor();//池中只能放一个线程
        //ExecutorService threadPool = Executors.newFixedThreadPool(5);//池中最多只能放5个线程
        ExecutorService threadPool = Executors.newCachedThreadPool();//池中线程数动态分配

        try {
            //执行任务
            for (int i = 0; i < 50; i++) {
                final int temp=i;
                //使用了线程池之后，要使用线程池来创建线程
                threadPool.execute(()->{
                    System.out.println(Thread.currentThread().getName()+"->"+temp);
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //关闭线程池
            threadPool.shutdown();
        }
    }
}
```

---



#### 10.2、七大参数

 `int corePoolSize`	核心线程池大小

 `int maximumPoolSize`	最大线程池大小

 `long keepAliveTime`	//存活时间（超过这个时间，超过核心线程池大小的其他闲置线程就会被关闭）

 `TimeUnit unit`	超时单位

 `BlockingQueue<Runnable> workQueue`	阻塞队列

 `ThreadFactory threadFactory`	线程工厂：创建线程，一般不用动

 `RejectedExecutionHandler handle`	拒绝策略

  

> **源码分析**

```java
//newSingleThreadExecutor()
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}

//newFixedThreadPool(int nThreads)
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }

//newCachedThreadPool()
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }

//本质：ThreadPoolExecutor()
//七大参数
public ThreadPoolExecutor(int corePoolSize,//核心线程池大小
                              int maximumPoolSize,//最大线程池大小
                              long keepAliveTime,//存活时间（超过这个时间，超过核心线程池大小的其他闲置线程就会被关闭）
                              TimeUnit unit,//超时单位
                              BlockingQueue<Runnable> workQueue,//阻塞队列
                              ThreadFactory threadFactory,//线程工厂：创建线程的，一般不用动
                              RejectedExecutionHandler handler//拒绝策略) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

![image-20210119142532623](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210119142532623.png)

![image-20210119144254867](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210119144254867.png)





#### **10.3、四种拒绝策略**

- `AbortPolicy`  丢出任务并抛出 RejectedExecutionException 异常。【默认】

***源码：***

```java
private static final RejectedExecutionHandler defaultHandler =
        new AbortPolicy();

public static class AbortPolicy implements RejectedExecutionHandler {
    
    public AbortPolicy() { }

    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        throw new RejectedExecutionException("Task " + r.toString() +
                                             " rejected from " +
                                             e.toString());
    }
}
```

---



- `CallerRunPolicy`  由调用线程（即当前线程池所在线程）处理该任务 【谁调用，谁处理】 

***源码：***

```java
public static class CallerRunsPolicy implements RejectedExecutionHandler {
    
    public CallerRunsPolicy() { }

    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            r.run();
        }
    }
}
```

---



- `DiscardPolicy`  直接丢弃任务，不抛出异常

***源码：***

```java
public static class DiscardPolicy implements RejectedExecutionHandler {
    
    public DiscardPolicy() { }

    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    }
}
```

---



- `DiscardOldestPolicy`  将最早进入队列的任务抛弃，之后再尝试加入队列 

***源码：***

```java
public static class DiscardOldestPolicy implements RejectedExecutionHandler {
  
    public DiscardOldestPolicy() { }

    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            e.getQueue().poll();
            e.execute(r);
        }
    }
}
```



#### 10.4、小结和拓展

---

最大线程池大小如何设置！

了解：IO密集型，CPU密集型：（调优）

```java
package juc.pool;

import java.util.Iterator;
import java.util.Random;
import java.util.concurrent.*;

/**
 * @Description: juc.pool
 * @version: 1.0
 */
/*
最大承载：maximumPoolSize+Queue.size

四种拒绝策略：
new ThreadPoolExecutor.AbortPolicy()
    超过最大承载抛出异常：java.util.concurrent.RejectedExecutionException

new ThreadPoolExecutor.CallerRunsPolicy()
    超过最大承载的任务将由 调用线程池的线程执行

new ThreadPoolExecutor.DiscardPolicy()
    超过最大承载的任务将被 直接抛弃，不会抛出异常

new ThreadPoolExecutor.DiscardOldestPolicy()
    当有超过最大承载的任务时，会将最早进入当前队列中的线程抛弃，然后再次调用execute方法尝试进入队列。
 */
public class ThreadPoolExecutorDemo02 {
    public static void main(String[] args) {

        //自定义线程池

        //最大线程池大小如何定义
        //1、CPU 密集型，几核就设置为几，可以保持CPU效率最高！
        //2、IO  密集型，判断程序中十分耗IO的线程数，设置最大线程池大小 大于此数即可。

        //获取CPU核数
        System.out.println(Runtime.getRuntime().availableProcessors());
        
        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(
                2,
                Runtime.getRuntime().availableProcessors(),
                3,
                TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(3),
                Executors.defaultThreadFactory(),
                new MyRejectedExecutionHandler()    //自定义拒绝策略
        );
        //执行任务
        try {
            for (int i = 1; i <= 10; i++) {
                System.out.println("添加第"+i+"个任务");
                //通过线程池创建线程
                threadPool.execute(new MyThread("任务"+i));
                Iterator<Runnable> iterator = threadPool.getQueue().iterator();
                while (iterator.hasNext()){
                    MyThread myThread = (MyThread) iterator.next();
                    System.out.println("队列:"+myThread.name);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //关闭线程池
            threadPool.shutdown();
        }
    }
}
//自定义线程
class MyThread implements Runnable{
    //线程名
    public String name;

    MyThread(String name) {
        this.name = name;
    }
    @Override
    public void run() {
        try {
            //让线程阻塞两秒--相当于增长业务处理时间
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("线程:"+Thread.currentThread().getName()+" 执行:"+name+"->run()");
    }
}
/*自定义拒绝策略：
让被拒绝的任务在一个新的线程中执行
 */
class MyRejectedExecutionHandler implements RejectedExecutionHandler{
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        new Thread(r,"新线程"+new Random().nextInt(10)).start();
    }
}
```



### 11、四大函数式接口（必须掌握）

---

需掌握：lambda表达式、链式编程、函数式接口、Stream流式计算

> **函数式接口：**只有一个方法的接口

```java
@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
//超级多的FunctionalInterface
//简化编程模型，在新版本的框架底层大量应用！
//foreach(消费者类型的函数式接口)
```



![image-20210119213252222](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210119213252222.png)



####  11.1、Function 函数式接口

![image-20210119230143338](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210119230143338.png)

```java
package juc.function;

import java.util.function.Function;

/*
Function 函数型接口，有一个输入参数，有一个输出参数
只要是 函数式接口，就可以用 lambda 表达式进行简化
 */
public class FunctionDemo {
    public static void main(String[] args) {
        //
        /*Function<String, String> function = new Function<String, String>() {
            @Override
            public String apply(String str) {
                return str;
            }
        };*/

        Function<String,String> function = str->{ return str; };
        System.out.println(function.apply("abc"));
    }
}
```



#### 11.2、Predicate 断定型接口

![image-20210119231932780](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210119231932780.png)

```java
package juc.function;

import java.util.function.Predicate;

/*
Predicate 断定型接口：有一个参数，返回值只能是boolean类型
 */
public class PredicateDemo {
    public static void main(String[] args) {
        //判断是否是空字符串
        /*Predicate<String> predicate = new Predicate<String>() {
            @Override
            public boolean test(String str) {
                return str.isEmpty();
            }
        };*/
        //Predicate<String> predicate = str->{return str.isEmpty();};
        Predicate<String> predicate = String::isEmpty;
        System.out.println(predicate.test(""));
    }
}
```



#### 11.3、Consumer