## 创建工程

注意：命令行都要使用管理员模式运行

1、创建一个名为 hello-vue 的工程 `vue init webpack hello-vue`

2、安装依赖，我们需要安装 vue-router、element-ui、sass-loader 和 node-sass 四个插件

```cmd
#进入工程目录
cd hello-vue
#安装 vue-router
npm install vue-router --save-dev
#安装 element-ui
npm i element-ui -S
#安装依赖
npm install
#安装 SASS 加载器
cnpm install sass-loader node-sass --save-dev
#启动测试
npm run dev
```

3、npm命令解释：

- `npm install moduleName`: 安装模块到项目目录下
- `npm install -g moduleName`: -g 的意思是将模块安装到全局，具体安装到磁盘的那个位置，要看 npm config prefix 的位置
- `npm install --save moduleName`: --save 的意思是将模块安装到项目目录下，并在package 文件的 dependencies 节点写入依赖，-S 为该命令的缩写
- `npm install --save-dev moduleName`: --save-dev 的意思是将模块安装到项目目录下，并在 package 文件的 devDependencies 节点写入依赖，-D 为该命令的缩写



## 安装Webpack

Webpack 是一款模块加载器兼打包工具,它能把各种资源,如 JS、JSX、ES6、SASS、LESS、图片等都作为模块来处理和使用。

**安装：**

```
npm install webpack -g
npm install webpack-cli -g
```

测试安装成功:

```
webpack -v
webpack-cli -v
```



## 配置

创建`webpack.config.js`文件

- entry: 入口文件,指定 webpack 用哪个文件作为项目的入口
- output: 输出,指定 webpack 把处理完成的文件放置到指定路径
- module: 模块,用于处理各种类型的文件
- plugins: 插件,如:热更新、代码重用等
- resolve: 设置路径指向
- watch: 监听,用于设置文件改动后直接打包

```js
module.exports={
    entry:'',
    output:{
        path:'',
        filename:''
    },
    module:{
        loaders:[
            {test:/\.js$/,loader:''}
        ]
    },
    plugins:{},
    resolve:{},
    wetch:true
}
```

直接运行`webpack`命令打包



## 使用Webpack

1. 创建项目

2. 创建一个名为 modules 的目录，用于放置 JS 模块等资源文件

3. 在 modules 下创建模块文件，如 zx.js ,用于编写 JS 模块相关代码

   ```js
   "use strict";//启用严格模式,ES6规范
   //暴露一个方法(只有暴露的方法(exports.)能被调用)
   exports.helloZX=function (){
       document.write("<h1>hello zx</h1>");
   };
   exports.helloZX1=function (){
       document.write("<h2>你好,周旭</h2>");
   };
   let helloZX2=function (){
       document.write("<h1>hello zx</h1>");
   }
   ```

4. 在 modules 下创建一个名为 main.js 的入口文件,用于打包时设置 entry 属性

   ```js
   "use strict";//启用严格模式,ES6规范
   //引入(接收)zx.js
   let zx=require("./zx");
   //调用zx.js中暴露的方法(只能调用暴露的方法类似于Java中的public修饰符)
   zx.helloZX();
   zx.helloZX1();
   ```

5. 在项目目录下创建 webpack.config.js 配置文件,使用 `webpack` 命令打包

   ```js
   //导出
   module.exports={
       entry:'./modules/main.js',     //入口
       output:{
           filename:'./js/bundle.js'  //输出
       }
   }
   ```

6. 在项目目录下创建 HTML 页面,如 index.html, 导入 webpack 打包后的 JS 文件

   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <title>Title</title>
   </head>
   <body>
   <!--前端的模块化开发-->
   <script src="dist/js/bundle.js"></script>
   </body>
   </html>
   ```

7. 在IDEA控制台中执行`webpack`;如果失败的话,就使用管理员权限运行即可!

8. 运行 HTML 看效果



**说明:**

```
# 参数 --watch 用于监听变化
webpack --watch
```





**目录结构:**

![image-20210410164754365](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210410164754365.png)



## 路由

### 路由嵌套

嵌套路由又称子路由，在实际应用中，通常由多层嵌套的组件组合而成。同样地，URL中各段动态路径也按某种结构对应嵌套的各层组件，例如：

![img](file:///C:\Users\Administrator\Documents\Tencent Files\386859692\Image\C2C\6446D1F4092DA49EF885B3A2DE103134.jpg)

1、用户信息组件，在views/user 目录下创建名为 Profile.vue 与List.vue的视图组件；

Profile.vue

```vue
<template>
  <!--所有元素不能在根节点下-->
  <div>
    <h1>个人信息</h1>
  </div>
</template>

<script>
export default {
  name: "Profile"
}
</script>

<style scoped>

</style>
```

List.vue

```vue
<template>
  <h1>用户列表</h1>
</template>

<script>
export default {
  name: "List"
}
</script>

<style scoped>

</style>

```

2、在index.js中配置子路由

main

```js
export default new Router({
  mode:'history', //去除路径#符号
  routes:[
    {
      path:'/main/:username',
      name:'main',
      component:Main,
      props:true,
      //子路由
      children:[
        {
          path:'/user/profile/:id/:name',
          name:'userProfile',
          component:Profile
        },
        {
          path:'/user/list',
          name:'userList',
          component: List,
          props:true  //开启通过参数传递。
        },
        //重定向
        {
        path: '/goHome',
        redirect:'/main'
        }
      ]
    }
  }
```





### 路由模式与404

路由模式有两种：

- hash：路径带 # 符号，如 http://localhost/#/login 
- history：路径不带 # 符号，如 http://localhost/login 

修改路由配置，代码如下：

```js
export default new Router({ 
    mode: 'history', 
    routes: [ ]
});
```

处理 404 创建一个名为 ==NotFound.vue== 的视图组件，代码如下：

```vue
<template>
  <h1>404,您的页面走丢了</h1>
</template>

<script>
export default {
  name: "NotFound"
}
</script>

<style scoped>

</style>
```

index.js中修改路由配置，代码如下：

```js
//导入路由
import NotFound from "../views/NotFound";
//添加路由
{
    path:'*',
    component: NotFound
}
```



### 路由钩子与异步请求

`beforeRouteEnter`: 在进入路由之前执行

`beforeRouteLeave`: 在离开路由之前执行

代码:

```js
export default {
  name: "Profile",
  //钩子函数（进入路由之前触发）
  beforeRouteEnter:(to, from, next)=>{
    console.log('准备进入Profile页');
    next();
  },
  //钩子函数（离开路由之前触发）
  beforeRouteLeave:(to, from, next)=>{
    console.log('准备离开Profile页');
    next();
  }
}
```

参数说明:

-   to: 路由将要跳转的路径信息
-   from: 路由跳转前的路径信息
-   next: 路由的控制参数
  - ​    next() 跳入下一个页面
  - ​    next('/path') 改变路由的跳转方向,使其跳到另一个路由
  - ​    next(false) 返回原来的页面
  - ​    next((vm)=>{}) 仅在beforeRouteEnter中可用,vm是组件实例

**在钩子函数中使用异步请求**

1、安装 axios、vue-axios

```
npm install --save axios vue-axios
```

2、将下面代码加入入口文件（main.js):

```js
import axios from 'axios'
import VueAxios from 'vue-axios'

Vue.use(VueAxios, axios)
```

3、准备数据，在static目录下建立mock文件夹创建data.json文件

![image-20210414153039285](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210414153039285.png)

```json
{
  "name": "狂神说Java",
  "url": "https://www.cnblogs.com/code-xu/",
  "page": 1,
  "address": {
    "street": "洪崖洞",
    "city": "重庆市",
    "country": "中国"
  }
}

```

4、创建获取数据的方法 getData()

```js
methods:{
    getData:function (){
      this.axios.get('http://localhost:8080/static/mock/data.json')//文件路径
      .then(function (response){
        console.log(response);//打开console可以看到获取的json数据
      })
    }
  }
```

5、在 beforeRouteEnter中调用此方法，获取数据。

```js
beforeRouteEnter:(to, from, next)=>{
    console.log('进入路由之前');
    next(vm => {
      vm.getData();//进入路由之前执行getData();
    });
  },
```

完整js代码

```js
export default {
  name: "Profile",
  /*钩子函数（进入路由之前触发）
  to:路由将要跳转的路径信息
  from:路由跳转前的路径信息
  next:路由的控制参数
    next() 跳入下一个页面
    next('/path') 改变路由的跳转方向,使其跳到另一个路由
    next(false) 返回原来的页面
    next((vm)=>{}) 仅在beforeRouteEnter中可用,vm是组件实例
  */
  beforeRouteEnter:(to, from, next)=>{
    console.log('进入路由之前');
    next(vm => {
      vm.getData();//进入路由之前执行getData();
    });
  },
  //钩子函数（离开路由之前触发）
  beforeRouteLeave:(to, from, next)=>{
    console.log('离开路由之前');
    next();
  },
  methods:{
    getData:function (){
      this.axios.get('http://localhost:8080/static/mock/data.json')
      .then(function (response){
        console.log(response);
      })
    }
  }
}
```

